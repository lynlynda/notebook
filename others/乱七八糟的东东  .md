# 乱七八糟的东东  
- ### mockjs生成模拟数据


	单元测试：mocha 
	
	
	公众号的种类：
	1 ,企业号
	2 , 服务号
	3 , 订阅号
	
	
	把本地的资源映射到公网的工具：
	1，ngrok
	2，localtunnel
	3，tunnel 
	微信开发：
	appID
	wx5603641aa0ff112d
	appsecret
	ff9770ff22d82e26fd09546891c18714
	
	
	Math.pow(x,y)
	可返回 x 的 y 次幂的值。
	foreach 退出循环的方法  
- ### git版本管理：

git clone +git地址：
	拷贝项目源代码
git add -A：
	所有untracked的文件添加到索引
git commit -m  +“提交说明”：
	记录变更到版本库
git push  提交到git  

git pull 更新


手动解决冲突：
git diff 查看冲突

回到过去：
git log  查看提交日志
复制commit id
git reset —hard  +复制的commit id

git reflog
 可以查看所有分支的所有操作记录   
  

- ### 目前需要复习

ECMAScript 6  已看
css3 ：            
{flex已看}

webpack
vue
自适应开发   已看

splice() 方法与 slice() 方法的作用是不同的，splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目,
方法会直接对数组进行修改。
slice() 方法可从已有的数组中返回选定的元素。不改变数组
最近面试的时候 就会问： vue的事件分发，jquery源码，babel的原理，浏览器的渲染机制，不同域名的页面之间的信息传递
细节方面会问： git进行版本管理的时候 出现冲突是什么样的表现形式，移动端的ui设计图是多大尺寸，  

- ### deferred对象就是jQuery的回调函数解决方案


AJAX
1.5版本以后

$.ajax(‘text.html’)
.done(function(){…})
.fail(function(){…})
.done(function(){…})
deferred对象的一大好处，就是它允许你自由添加多个回调函数，它们按照添加顺序执行。deferred对象的另一大好处，就是它允许你为多个事件指定一个回调函数，这是传统写法做不到的。请看下面的代码，它用到了一个新的方法$.when()：
$.when($.ajax("test1.html"), $.ajax("test2.html"))
　　.done(function(){ alert("哈哈，成功了！"); })
　　.fail(function(){ alert("出错啦！"); });
　　[相关链接](http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html)  
　　　 
- ### 1像素边框的解决方案
iphone6 显示较粗
line-height: 1
根据自己字体 * 1 来算行距
移动端字体解决方案  

- ### transition :
transition: property duration timing-function delay;

属性是一个简写属性，用于设置四个过渡属性：
	•	transition-property
	•	transition-duration
	•	transition-timing-function
	•	transition-delay


animation 属性是一个简写属性，用于设置六个动画属性：
animation: name duration timing-function delay iteration-count direction;

	•	animation-name
	•	animation-duration
	•	animation-timing-function
	•	animation-delay
	•	animation-iteration-count规定动画应该播放的次数。
	•	animation-direction规定是否应该轮流反向播放动画。
	•	

- ### 第四周  网站优化改造 
1，css

将css文件改成less文件
css分成组件进行管理

css内的import  和 css内使用表达式影响性能，需要把他们改掉

用gulp编译less，压缩css，合并css文件为一个文件，加md5戳

css文件放到一台和主域名不一样的机器，减少cookie体积

css放到cdn上（具体步骤）



2，js

js操作dom是昂贵的，尽可能将js分成组件

主页面只请求一个入口js
￼

将之前同步的js改成异步加载，使用AMD加载器加载js模块。为什么改成异步的？因为同步加载会阻塞浏览器。
模块加载器控制js模块的加载顺序，提高js的并发下载能力
用sea.js  require.js加载器

用gulp或其他工具将js压缩，打包，合并，然后上CDN，告诉运维启动gzip压缩（gzip，相当于服务器把请求文件打包压缩成zip文件传到浏览器，浏览器自行解压的过程，这个过程和gulp压缩是两个压缩过程）
让运维把不经常改变的文件，例如seajs，的过期时间延长，添加expires头

将页面img标签中src为空的标签删除，因为它也好占用请求时间，延迟onload的时间，也会延迟ready的时间，因为空的src也是页面结构的一部分。影响页面的重绘重排

不能无限制合并，针对移动端，33kb的js文件和css文件是极限，他们对于浏览器来说是非常大的开销，不同团队有不同规定，一般控制在10kb，8kb。但是不会超过33kb。pc端无所谓。

.js换成.es



3，html
second open source 秒开率
控制html：
1）语义化
2）精准控制
3）使用深度（image可以加载图片，还可以统计移动端网速，怎么统计呢：js里new一个image，src=某个网站的图片地址，图片大小／（endtime-starttime），然后将image=null。）



4，图片
如果不是以高质量图片为主的网站（婚纱照，摄影艺术等），建议都用png，png能无损压缩
图片放到cdn
雪碧图
矢量绘图，用css画，css可以调起硬件加速，画的效率高
font-face

5，node
1)  node可以使前后端分离
2)  node可以切割无用数据（例如后台返回一堆数据，但是前台只需要一个key）
3)  后台不配合前台把组件做成异步的。node可以 。 正常后台吐json，但是做成异步组件后台需要吐一个对象包含js，css，html


6,DNS预解析：在没请求这些资源之前，先将这些资源解析，然后缓存了
￼


7，pjax 实现spa的库  
  
- ### 利用setTimeout(fn,0)
的特性，可以帮助我们在某些极端场景下，修正浏览器的下一个任务。[链接](http://www.cnblogs.com/silin6/p/4333999.html)   
 
- # 对象   
	    
1. ### 为什么使用构造函数  
   用普通函数生成的对象，其类型（class）返回都是Object，这样使用中毫无辨识度。为了解决这个问题，使用了构造函数：
	 - function作为构造函数（通过new操作符调用）的时候会返回一个类型为function的name的对象，这样就解决了辨识度问题。
	 - function实例的“作用域”内（注意是实例的作用域内，不是实例本身）有一个constructor属性，这个属性可以指示其构造器 。 
2. ### 构造函数特征  
	- 任何函数使用new表达式就是构造函数  
	- 每个函数自动设置了prototype属性，他是一个对象  
	- 每个对象都有个内部属性__proto__(规范中无此属性，但是浏览器中都这样实现)都指向其类型的prototype属性  
3. ### 原型链  
	例如 [1,2,3]查找valueOf方法  
	1），查找自身属性和方法  
	2），没找到，通过__proto__属性，找到其类型“Array”的prototype进行查找  
	3），没找到，通过类似方法找到prototype类型的prototype，查找，找到返回  
  
4. ### 抽象重复  
	- 所有实例都会通过原型链引用到类型的prototype  
	- prototype相当于 特定类型里所有实例都可以访问的一个公共容器  
	- 重复的东西移动到公共容器里放一份即可   
![prototype](https://raw.githubusercontent.com/lynlynda/notebook/master/others/prototype.png) 
  
 -  # 作用域
 	- ### 变量的种类  
 	1.实例变量：类的实例才能访问的变量  
 	2.静态变量：直接类型对象能访问到的变量  
 	3.私有变量：当前作用域内有效的变量  
 	  
 	```  
 	  
	 	function ClassA(){  
	 		var a = 1;//私有变量，只有函数内部可以访问  
	 		this.b = 2;//实例变量，只有实例可以访问    
	 	}  
	 	ClassA.c = 3;//静态变量，也就是属性，只有类可以访问，实例不可以访问  
	 	
	 	  
	 	console.log(a) 			// error  
	 	console.log(ClassA.b)  // undefined 
	 	console.log(ClassA.c)  // 3  
	 	
	 	var classa = new ClassA();  
	 	console.log(ClassA.a) 	// undefined  
	 	console.log(ClassA.b)  // 2 
	 	console.log(ClassA.c)  // undefined    
 	
 	``` 
 	
  

  
- # jQuery  
1. #### 最外层为何传入window,undefined?  
  源码：  

	```
	(function(window, undefined){  
		
	})(window, undefined)  
	
	```  
 
	最外层为何传入window,undefined,
	因为代码上线的时候会经过压缩，例如：
	  
		```
		function print(){  
		 
			var first_name = "Byron";   
			 
			var last_name = "Sun";   
			 
			window.name = first_name + last_name;  
			
		}   
		
		```  
	会被压缩成   
	 
		```  
		function print(){var a='Byron',b='Sun';w.name=a+b;}  
		
		```    
	浏览器不认识 'w' 变量。  
	因此源码相当于：  
	  
	```
	(function(w, undefined){  
		...  
		w.name = 'gl';  
		...
		
	})(window, undefined)  
	
	```  
参数无所谓叫什么，只要传入的参数是window即可。  
另外，函数在找变量的时候是层层向上，先找函数内，然后找参数，然后找函数外层。但是这时候穿进window，就省去了寻找变量的过程，执行效率会更好。  


	undefined传入是为了防止undefined被重写：  
	
	```  
	  （function(){  
	  
			var undefined = 123;   
			 
			alert(undefined)  
			
		}）()  // 123 
	```
2. ###  jQuery 和 zepto
	jQuery最核心的是dom操作和ajax，zepto与之区别就是：  
	1. 去除了兼容性代码
	2. 只加载了这几个核心模块，其他的需要用到的时候再加载相关模块 
	3. 选择器使用了js的原生方法（document.queryElectorAll,这些执行效率很高，因为是c++编译到浏览器内部的，但是有bug，拓展性不好，不如jquery），因为选择器（Sizzle）写起来是非常长的  
